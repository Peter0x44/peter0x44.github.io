[{"content":"When executing various Makefiles with w64devkit, you can occasionally run across a Windows program with a Makefile written for cmd.exe. Often the only thing broken about them is the conventional clean target, which uses del.exe and will only work under cmd.exe.\nmake clean\rdel *.o /s\rsh: del: not found\rmake: *** [Makefile:734: clean] Error 127 Confusingly, even if you then open cmd.exe and run make clean from there, you still get the same error!\nThe reason for this is that GNU Make for Windows searches the PATH for an sh.exe before selecting cmd.exe. This is documented in GNU Make\u0026rsquo;s README.W32:\nGNU Make and sh.exe:\rThis port prefers if you have a working sh.exe somewhere on\ryour system. If you don\u0026#39;t have sh.exe, the port falls back to\rMSDOS mode for launching programs (via a batch file). The\rMSDOS mode style execution has not been tested that carefully\rthough (The author uses GNU bash as sh.exe). Until now, I have only referred to make, but mingw32-make (a conventional prefix for several mingw(-w64) toolchains) does not differ in any way but name.\nThe most immediate solution is to run make clean SHELL=cmd. This will work, however it also brings in all the issues and misbehavior that come from cmd.exe itself, and won\u0026rsquo;t work on some machines. Back in 2020 and 2021, when I was still in school, the computers there specifically had cmd.exe disabled. All it could do was print The command prompt has been disabled by your administrator.. However, busybox sh started through w64devkit functioned just fine! Of course, due to this restriction, none of the Makefiles could use cmd.exe.\nIs there a way we could query what shell is executing build rules for recipes?\nThe answer is yes! Though it requires extensions from GNU Make. I\u0026rsquo;ve seen buggy code out there that tries to make an attempt, but gets it all wrong.\nBut first, I will clarify what doesn\u0026rsquo;t work, so you can spot it in code review, or not waste your time testing it.\n1) Checking the presence of $ComSpec\nPremake was trying to do this. This method might even insidiously seem to work, because all the unix-type shells on Windows capitalize environment variables, and GNU Make does case insensitive comparisons. You might think this fact is possible to harness to do shell detection, however, what really ends up being detected is whether the shell that invoked make is cmd or sh, not necessarily what the recipes themselves are executed with. So make clean in cmd.exe with an sh.exe present will be detected as cmd as well.\nUnder every shell I tried, $COMSPEC was present and pointing to cmd.exe. I have not found a single circumstance where this variable differs, even in PowerShell. So I\u0026rsquo;m not sure it\u0026rsquo;s a reliable way of detecting anything. I am not sure what it did ever detect, if anything.\nPS C:\\WINDOWS\\system32\u0026gt; echo $env:ComSpec\rC:\\WINDOWS\\system32\\cmd.exe 2) Checking the value of $(SHELL)\nMake does not set this if it is unset. So it can only tell you if the value is being overridden or not, meaning your makefile cannot simply work with make in both circumstances of \u0026ldquo;have sh.exe\u0026rdquo; and \u0026ldquo;don\u0026rsquo;t have sh.exe\u0026rdquo;. Setting it in the Makefile itself to signal what shell you would like make to use also does not work.\nNow, on to the method that actually works. Thanks to Kaz Kylheku from the GNU Make mailing list for telling me about this, though later I have talked to several people who seemed to know of this independently. I\u0026rsquo;ve still never seen it documented on another blog, so I will do so here.\nThe solution is to execute echo as a \u0026ldquo;polyglot test\u0026rdquo;. Specifically, it exploits how cmd and sh handle quotes.\nIn cmd.exe, echo \u0026quot;test\u0026quot; outputs \u0026quot;test\u0026quot; with the quotes included. Under sh.exe, it strips the quotes and outputs just test. We can combine this behavioral difference with GNU make\u0026rsquo;s Conditional Syntax extension:\nSHELLTYPE=sh\rifeq ($(shell echo \u0026#34;test\u0026#34;), \u0026#34;test\u0026#34;)\rSHELLTYPE=cmd\rendif Then you can use this variable in your clean target:\n.PHONY: clean\rclean:\rifeq ($(SHELLTYPE), sh)\rrm *.o\relse\rdel /q *.o\rendif Now, your clean target will work just fine under both sh.exe and cmd.exe.\nOther Common Cross-Shell Issues\nAnother operation that makefiles use regularly is mkdir. This one coincidentally has a common usage that works identically on Windows and Linux: mkdir \u0026lt;dir\u0026gt;. However, mkdir -p is effectively the default behavior on Windows, so if you need the -p flag, you\u0026rsquo;re back to writing shell-specific commands.\nThe last problematic command that sometimes appears is touch, which has no cmd.exe equivalent I could find. I have no good solution for this one if your Makefile relies on it. Thankfully, it\u0026rsquo;s rare in practice.\nA Better Build System Design?\nAll of this complexity could have been avoided if common file operations were built-in to make itself, as intrinsics. Ninja, for comparison, requires you to explicitly declare outputs, so it knows exactly what to delete without shell commands.\nHowever, Ninja lacks some of Make\u0026rsquo;s pleasing \u0026ldquo;dumbness\u0026rdquo;, and is much less pleasant to write by hand. If you\u0026rsquo;re designing a replacement for make, I\u0026rsquo;d highly suggest limiting shell access and adding built-in operations for at least rm, mkdir, and touch. An escape hatch to the shell might still be needed for some unusual cases, but we shouldn\u0026rsquo;t need shell commands just to delete a file. The fewer dependencies a build system has, the more robust it will be.\nBonus Debugging Tip\nIf you\u0026rsquo;re debugging a makefile and want to see exactly what shell commands it runs (and it doesn\u0026rsquo;t already have verbose output configured), you can use make SHELL=\u0026quot;sh -x\u0026quot; to trace it.\n","permalink":"/posts/make_shell_cmd/","summary":"\u003cp\u003eWhen executing various Makefiles with \u003ca href=\"https://github.com/skeeto/w64devkit\"\u003ew64devkit\u003c/a\u003e, you can occasionally run across a Windows program with a Makefile written for cmd.exe. Often the only thing broken about them is the conventional \u003ccode\u003eclean\u003c/code\u003e target, which uses \u003ccode\u003edel.exe\u003c/code\u003e and will only work under \u003ccode\u003ecmd.exe\u003c/code\u003e.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emake clean\r\ndel *.o /s\r\nsh: del: not found\r\nmake: *** [Makefile:734: clean] Error 127\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eConfusingly, even if you then open \u003ccode\u003ecmd.exe\u003c/code\u003e and run \u003ccode\u003emake clean\u003c/code\u003e from there, you still get the same error!\u003c/p\u003e","title":"Make, shells and polyglot tests - How to write a cross-shell clean target."}]